const fs = require('fs-extra');
const path = require('path');
const phantom = require('phantom');
const sha256 = require('sha256');
const sleep = require('util').promisify(setTimeout);

module.exports = (options = {}) => {
  const defwaiting = +options.waiting || 1000;
  const expire = +options.expire || 60 * 60 * 1000;
  const capturedir = options.capturedir || path.join(process.cwd(), '.cache');
  const baseurl = options.baseurl;

  if( !baseurl ) throw new Error('missing options.baseurl');

  let instance;

  const resourcefilter = function(requestData, request) {
    if( /\.css$/.test(requestData.url) ) {
      request.abort();
    }
  };

  const tosavename = (src) => {
    src = src.substring(1);
    const pathname = src.split('?')[0] || 'index';
    let qry = src.split('?').slice(1).join('?');
    if( !qry ) return '/' + pathname;
    return '/' + pathname + '?' + sha256(qry);
  };

  return {
    cachefile(src) {
      const file = path.join(capturedir, tosavename(src));
      if( fs.existsSync(file) ) {
        const stats = fs.statSync(file);
        const retentionms = (new Date().getTime() - stats.mtime) / 1000;

        if( retentionms < expire ) return file;
      }

      return null;
    },
    async capture(src, waiting) {
      if( !src ) throw new Error('missing src');
      if( !src.startsWith('/') ) throw new Error('src must be a absolute path');

      instance = instance || await phantom.create(options.argv || ['--ignore-ssl-errors=yes', '--load-images=no']);

      const page = await instance.createPage();
      page.on('onResourceRequested', true, resourcefilter);

      await page.open(baseurl + src);
      await sleep(waiting || defwaiting);
      const html = await (page.property('content') || '') + `<!-- generated by httpd-ssr '${src}' at ${new Date().toISOString()}' -->`;

      const file = path.join(capturedir, tosavename(src));
      console.log('file', src, tosavename(src));
      const dirname = path.dirname(file);
      fs.ensureDirSync(dirname);
      fs.writeFileSync(file, html, {
        flag: 'w'
      });
      return html;
    },
    async close() {
      await instance.exit();
    }
  };
};
